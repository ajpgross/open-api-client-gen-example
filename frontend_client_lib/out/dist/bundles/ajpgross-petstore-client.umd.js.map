{"version":3,"file":"ajpgross-petstore-client.umd.js","sources":["../../encoder.ts","../../variables.ts","../../configuration.ts","../../api/pet.service.ts","../../api/store.service.ts","../../api/user.service.ts","../../api/api.ts","../../model/order.ts","../../model/pet.ts","../../api.module.ts","../../ajpgross-petstore-client.ts"],"sourcesContent":["import { HttpParameterCodec } from '@angular/common/http';\n\n/**\n * Custom HttpParameterCodec\n * Workaround for https://github.com/angular/angular/issues/18261\n */\nexport class CustomHttpParameterCodec implements HttpParameterCodec {\n    encodeKey(k: string): string {\n        return encodeURIComponent(k);\n    }\n    encodeValue(v: string): string {\n        return encodeURIComponent(v);\n    }\n    decodeKey(k: string): string {\n        return decodeURIComponent(k);\n    }\n    decodeValue(v: string): string {\n        return decodeURIComponent(v);\n    }\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const BASE_PATH = new InjectionToken<string>('basePath');\nexport const COLLECTION_FORMATS = {\n    'csv': ',',\n    'tsv': '   ',\n    'ssv': ' ',\n    'pipes': '|'\n}\n","import { HttpParameterCodec } from '@angular/common/http';\n\nexport interface ConfigurationParameters {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials?: {[ key: string ]: string | (() => string | undefined)};\n}\n\nexport class Configuration {\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    apiKeys?: {[ key: string ]: string};\n    username?: string;\n    password?: string;\n    /**\n     *  @deprecated Since 5.0. Use credentials instead\n     */\n    accessToken?: string | (() => string);\n    basePath?: string;\n    withCredentials?: boolean;\n    encoder?: HttpParameterCodec;\n    /**\n     * The keys are the names in the securitySchemes section of the OpenAPI\n     * document. They should map to the value used for authentication\n     * minus any standard prefixes such as 'Basic' or 'Bearer'.\n     */\n    credentials: {[ key: string ]: string | (() => string | undefined)};\n\n    constructor(configurationParameters: ConfigurationParameters = {}) {\n        this.apiKeys = configurationParameters.apiKeys;\n        this.username = configurationParameters.username;\n        this.password = configurationParameters.password;\n        this.accessToken = configurationParameters.accessToken;\n        this.basePath = configurationParameters.basePath;\n        this.withCredentials = configurationParameters.withCredentials;\n        this.encoder = configurationParameters.encoder;\n        if (configurationParameters.credentials) {\n            this.credentials = configurationParameters.credentials;\n        }\n        else {\n            this.credentials = {};\n        }\n\n        // init default api_key credential\n        if (!this.credentials['api_key']) {\n            this.credentials['api_key'] = () => {\n                if (this.apiKeys === null || this.apiKeys === undefined) {\n                    return undefined;\n                } else {\n                    return this.apiKeys['api_key'] || this.apiKeys['api_key'];\n                }\n            };\n        }\n\n        // init default petstore_auth credential\n        if (!this.credentials['petstore_auth']) {\n            this.credentials['petstore_auth'] = () => {\n                return typeof this.accessToken === 'function'\n                    ? this.accessToken()\n                    : this.accessToken;\n            };\n        }\n    }\n\n    /**\n     * Select the correct content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param contentTypes - the array of content types that are available for selection\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\n        if (contentTypes.length === 0) {\n            return undefined;\n        }\n\n        const type = contentTypes.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return contentTypes[0];\n        }\n        return type;\n    }\n\n    /**\n     * Select the correct accept content-type to use for a request.\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\n     * If no content type is found return the first found type if the contentTypes is not empty\n     * @param accepts - the array of content types that are available for selection.\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\n     */\n    public selectHeaderAccept(accepts: string[]): string | undefined {\n        if (accepts.length === 0) {\n            return undefined;\n        }\n\n        const type = accepts.find((x: string) => this.isJsonMime(x));\n        if (type === undefined) {\n            return accepts[0];\n        }\n        return type;\n    }\n\n    /**\n     * Check if the given MIME is a JSON MIME.\n     * JSON MIME examples:\n     *   application/json\n     *   application/json; charset=UTF8\n     *   APPLICATION/JSON\n     *   application/vnd.company+json\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\n     * @return True if the given MIME is JSON, false otherwise.\n     */\n    public isJsonMime(mime: string): boolean {\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\n        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\n    }\n\n    public lookupCredential(key: string): string | undefined {\n        const value = this.credentials[key];\n        return typeof value === 'function'\n            ? value()\n            : value;\n    }\n}\n","/**\n * Swagger Petstore - OpenAPI 3.0\n * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we\\'ve switched to the design first approach! You can now help us improve the API whether it\\'s by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\n *\n * The version of the OpenAPI document: 1.0.9\n * Contact: apiteam@swagger.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { ApiResponse } from '../model/models';\nimport { Pet } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\nimport {\n    PetServiceInterface\n} from './pet.serviceInterface';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class PetService implements PetServiceInterface {\n\n    protected basePath = 'https://petstore3.swagger.io/api/v3';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Add a new pet to the store\n     * Add a new pet to the store\n     * @param pet Create a new pet in the store\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public addPet(pet: Pet, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<Pet>;\n    public addPet(pet: Pet, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<Pet>>;\n    public addPet(pet: Pet, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<Pet>>;\n    public addPet(pet: Pet, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n        if (pet === null || pet === undefined) {\n            throw new Error('Required parameter pet was null or undefined when calling addPet.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml',\n            'application/x-www-form-urlencoded'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<Pet>(`${this.configuration.basePath}/pet`,\n            pet,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Deletes a pet\n     * @param petId Pet id to delete\n     * @param apiKey \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deletePet(petId: number, apiKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public deletePet(petId: number, apiKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public deletePet(petId: number, apiKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public deletePet(petId: number, apiKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n        if (petId === null || petId === undefined) {\n            throw new Error('Required parameter petId was null or undefined when calling deletePet.');\n        }\n\n        let headers = this.defaultHeaders;\n        if (apiKey !== undefined && apiKey !== null) {\n            headers = headers.set('api_key', String(apiKey));\n        }\n\n        let credential: string | undefined;\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/pet/${encodeURIComponent(String(petId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Finds Pets by status\n     * Multiple status values can be provided with comma separated strings\n     * @param status Status values that need to be considered for filter\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public findPetsByStatus(status?: 'available' | 'pending' | 'sold', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<Array<Pet>>;\n    public findPetsByStatus(status?: 'available' | 'pending' | 'sold', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<Array<Pet>>>;\n    public findPetsByStatus(status?: 'available' | 'pending' | 'sold', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<Array<Pet>>>;\n    public findPetsByStatus(status?: 'available' | 'pending' | 'sold', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (status !== undefined && status !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>status, 'status');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<Pet>>(`${this.configuration.basePath}/pet/findByStatus`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Finds Pets by tags\n     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.\n     * @param tags Tags to filter by\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public findPetsByTags(tags?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<Array<Pet>>;\n    public findPetsByTags(tags?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<Array<Pet>>>;\n    public findPetsByTags(tags?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<Array<Pet>>>;\n    public findPetsByTags(tags?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (tags) {\n            tags.forEach((element) => {\n                queryParameters = this.addToHttpParams(queryParameters,\n                  <any>element, 'tags');\n            })\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Array<Pet>>(`${this.configuration.basePath}/pet/findByTags`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find pet by ID\n     * Returns a single pet\n     * @param petId ID of pet to return\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getPetById(petId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<Pet>;\n    public getPetById(petId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<Pet>>;\n    public getPetById(petId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<Pet>>;\n    public getPetById(petId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n        if (petId === null || petId === undefined) {\n            throw new Error('Required parameter petId was null or undefined when calling getPetById.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (api_key) required\n        credential = this.configuration.lookupCredential('api_key');\n        if (credential) {\n            headers = headers.set('api_key', credential);\n        }\n\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Pet>(`${this.configuration.basePath}/pet/${encodeURIComponent(String(petId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update an existing pet\n     * Update an existing pet by Id\n     * @param pet Update an existent pet in the store\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePet(pet: Pet, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<Pet>;\n    public updatePet(pet: Pet, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<Pet>>;\n    public updatePet(pet: Pet, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<Pet>>;\n    public updatePet(pet: Pet, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n        if (pet === null || pet === undefined) {\n            throw new Error('Required parameter pet was null or undefined when calling updatePet.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml',\n            'application/x-www-form-urlencoded'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.put<Pet>(`${this.configuration.basePath}/pet`,\n            pet,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Updates a pet in the store with form data\n     * @param petId ID of pet that needs to be updated\n     * @param name Name of pet that needs to be updated\n     * @param status Status of pet that needs to be updated\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updatePetWithForm(petId: number, name?: string, status?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public updatePetWithForm(petId: number, name?: string, status?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public updatePetWithForm(petId: number, name?: string, status?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public updatePetWithForm(petId: number, name?: string, status?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n        if (petId === null || petId === undefined) {\n            throw new Error('Required parameter petId was null or undefined when calling updatePetWithForm.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (name !== undefined && name !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>name, 'name');\n        }\n        if (status !== undefined && status !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>status, 'status');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<any>(`${this.configuration.basePath}/pet/${encodeURIComponent(String(petId))}`,\n            null,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * uploads an image\n     * @param petId ID of pet to update\n     * @param additionalMetadata Additional Metadata\n     * @param body \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public uploadFile(petId: number, additionalMetadata?: string, body?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<ApiResponse>;\n    public uploadFile(petId: number, additionalMetadata?: string, body?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<ApiResponse>>;\n    public uploadFile(petId: number, additionalMetadata?: string, body?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<ApiResponse>>;\n    public uploadFile(petId: number, additionalMetadata?: string, body?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n        if (petId === null || petId === undefined) {\n            throw new Error('Required parameter petId was null or undefined when calling uploadFile.');\n        }\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (additionalMetadata !== undefined && additionalMetadata !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>additionalMetadata, 'additionalMetadata');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (petstore_auth) required\n        credential = this.configuration.lookupCredential('petstore_auth');\n        if (credential) {\n            headers = headers.set('Authorization', 'Bearer ' + credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/octet-stream'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<ApiResponse>(`${this.configuration.basePath}/pet/${encodeURIComponent(String(petId))}/uploadImage`,\n            body,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Swagger Petstore - OpenAPI 3.0\n * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we\\'ve switched to the design first approach! You can now help us improve the API whether it\\'s by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\n *\n * The version of the OpenAPI document: 1.0.9\n * Contact: apiteam@swagger.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { Order } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\nimport {\n    StoreServiceInterface\n} from './store.serviceInterface';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class StoreService implements StoreServiceInterface {\n\n    protected basePath = 'https://petstore3.swagger.io/api/v3';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Delete purchase order by ID\n     * For valid response try integer IDs with value &lt; 1000. Anything above 1000 or nonintegers will generate API errors\n     * @param orderId ID of the order that needs to be deleted\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteOrder(orderId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public deleteOrder(orderId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public deleteOrder(orderId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public deleteOrder(orderId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n        if (orderId === null || orderId === undefined) {\n            throw new Error('Required parameter orderId was null or undefined when calling deleteOrder.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/store/order/${encodeURIComponent(String(orderId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Returns pet inventories by status\n     * Returns a map of status codes to quantities\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getInventory(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<{ [key: string]: number; }>;\n    public getInventory(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<{ [key: string]: number; }>>;\n    public getInventory(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<{ [key: string]: number; }>>;\n    public getInventory(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let credential: string | undefined;\n        // authentication (api_key) required\n        credential = this.configuration.lookupCredential('api_key');\n        if (credential) {\n            headers = headers.set('api_key', credential);\n        }\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<{ [key: string]: number; }>(`${this.configuration.basePath}/store/inventory`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Find purchase order by ID\n     * For valid response try integer IDs with value &lt;&#x3D; 5 or &gt; 10. Other values will generated exceptions\n     * @param orderId ID of order that needs to be fetched\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getOrderById(orderId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<Order>;\n    public getOrderById(orderId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<Order>>;\n    public getOrderById(orderId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<Order>>;\n    public getOrderById(orderId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n        if (orderId === null || orderId === undefined) {\n            throw new Error('Required parameter orderId was null or undefined when calling getOrderById.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<Order>(`${this.configuration.basePath}/store/order/${encodeURIComponent(String(orderId))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Place an order for a pet\n     * Place a new order in the store\n     * @param order \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public placeOrder(order?: Order, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<Order>;\n    public placeOrder(order?: Order, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpResponse<Order>>;\n    public placeOrder(order?: Order, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json'}): Observable<HttpEvent<Order>>;\n    public placeOrder(order?: Order, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml',\n            'application/x-www-form-urlencoded'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<Order>(`${this.configuration.basePath}/store/order`,\n            order,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","/**\n * Swagger Petstore - OpenAPI 3.0\n * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we\\'ve switched to the design first approach! You can now help us improve the API whether it\\'s by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\n *\n * The version of the OpenAPI document: 1.0.9\n * Contact: apiteam@swagger.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n/* tslint:disable:no-unused-variable member-ordering */\n\nimport { Inject, Injectable, Optional }                      from '@angular/core';\nimport { HttpClient, HttpHeaders, HttpParams,\n         HttpResponse, HttpEvent, HttpParameterCodec }       from '@angular/common/http';\nimport { CustomHttpParameterCodec }                          from '../encoder';\nimport { Observable }                                        from 'rxjs';\n\nimport { User } from '../model/models';\n\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\nimport { Configuration }                                     from '../configuration';\nimport {\n    UserServiceInterface\n} from './user.serviceInterface';\n\n\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class UserService implements UserServiceInterface {\n\n    protected basePath = 'https://petstore3.swagger.io/api/v3';\n    public defaultHeaders = new HttpHeaders();\n    public configuration = new Configuration();\n    public encoder: HttpParameterCodec;\n\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\n        if (configuration) {\n            this.configuration = configuration;\n        }\n        if (typeof this.configuration.basePath !== 'string') {\n            if (typeof basePath !== 'string') {\n                basePath = this.basePath;\n            }\n            this.configuration.basePath = basePath;\n        }\n        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();\n    }\n\n\n    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {\n        if (typeof value === \"object\" && value instanceof Date === false) {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value);\n        } else {\n            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);\n        }\n        return httpParams;\n    }\n\n    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {\n        if (value == null) {\n            return httpParams;\n        }\n\n        if (typeof value === \"object\") {\n            if (Array.isArray(value)) {\n                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));\n            } else if (value instanceof Date) {\n                if (key != null) {\n                    httpParams = httpParams.append(key,\n                        (value as Date).toISOString().substr(0, 10));\n                } else {\n                   throw Error(\"key may not be null if value is Date\");\n                }\n            } else {\n                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(\n                    httpParams, value[k], key != null ? `${key}.${k}` : k));\n            }\n        } else if (key != null) {\n            httpParams = httpParams.append(key, value);\n        } else {\n            throw Error(\"key may not be null if value is not object or array\");\n        }\n        return httpParams;\n    }\n\n    /**\n     * Create user\n     * This can only be done by the logged in user.\n     * @param user Created user object\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createUser(user?: User, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<User>;\n    public createUser(user?: User, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpResponse<User>>;\n    public createUser(user?: User, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<HttpEvent<User>>;\n    public createUser(user?: User, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json' | 'application/xml'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/json',\n                'application/xml'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml',\n            'application/x-www-form-urlencoded'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<User>(`${this.configuration.basePath}/user`,\n            user,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Creates list of users with given input array\n     * Creates list of users with given input array\n     * @param user \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public createUsersWithListInput(user?: Array<User>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<User>;\n    public createUsersWithListInput(user?: Array<User>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<User>>;\n    public createUsersWithListInput(user?: Array<User>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<User>>;\n    public createUsersWithListInput(user?: Array<User>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.post<User>(`${this.configuration.basePath}/user/createWithList`,\n            user,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Delete user\n     * This can only be done by the logged in user.\n     * @param username The name that needs to be deleted\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public deleteUser(username: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public deleteUser(username: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public deleteUser(username: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public deleteUser(username: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n        if (username === null || username === undefined) {\n            throw new Error('Required parameter username was null or undefined when calling deleteUser.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.delete<any>(`${this.configuration.basePath}/user/${encodeURIComponent(String(username))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Get user by user name\n     * @param username The name that needs to be fetched. Use user1 for testing. \n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public getUserByName(username: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<User>;\n    public getUserByName(username: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<User>>;\n    public getUserByName(username: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<User>>;\n    public getUserByName(username: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n        if (username === null || username === undefined) {\n            throw new Error('Required parameter username was null or undefined when calling getUserByName.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<User>(`${this.configuration.basePath}/user/${encodeURIComponent(String(username))}`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Logs user into the system\n     * @param username The user name for login\n     * @param password The password for login in clear text\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public loginUser(username?: string, password?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<string>;\n    public loginUser(username?: string, password?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpResponse<string>>;\n    public loginUser(username?: string, password?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<HttpEvent<string>>;\n    public loginUser(username?: string, password?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/xml' | 'application/json'}): Observable<any> {\n\n        let queryParameters = new HttpParams({encoder: this.encoder});\n        if (username !== undefined && username !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>username, 'username');\n        }\n        if (password !== undefined && password !== null) {\n          queryParameters = this.addToHttpParams(queryParameters,\n            <any>password, 'password');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n                'application/xml',\n                'application/json'\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<string>(`${this.configuration.basePath}/user/login`,\n            {\n                params: queryParameters,\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Logs out current logged in user session\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public logoutUser(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public logoutUser(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public logoutUser(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public logoutUser(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.get<any>(`${this.configuration.basePath}/user/logout`,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n    /**\n     * Update user\n     * This can only be done by the logged in user.\n     * @param username name that need to be deleted\n     * @param user Update an existent user in the store\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\n     * @param reportProgress flag to report request and response progress.\n     */\n    public updateUser(username: string, user?: User, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<any>;\n    public updateUser(username: string, user?: User, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpResponse<any>>;\n    public updateUser(username: string, user?: User, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined}): Observable<HttpEvent<any>>;\n    public updateUser(username: string, user?: User, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined}): Observable<any> {\n        if (username === null || username === undefined) {\n            throw new Error('Required parameter username was null or undefined when calling updateUser.');\n        }\n\n        let headers = this.defaultHeaders;\n\n        let httpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;\n        if (httpHeaderAcceptSelected === undefined) {\n            // to determine the Accept header\n            const httpHeaderAccepts: string[] = [\n            ];\n            httpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);\n        }\n        if (httpHeaderAcceptSelected !== undefined) {\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\n        }\n\n\n        // to determine the Content-Type header\n        const consumes: string[] = [\n            'application/json',\n            'application/xml',\n            'application/x-www-form-urlencoded'\n        ];\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\n        if (httpContentTypeSelected !== undefined) {\n            headers = headers.set('Content-Type', httpContentTypeSelected);\n        }\n\n        let responseType_: 'text' | 'json' = 'json';\n        if(httpHeaderAcceptSelected && httpHeaderAcceptSelected.startsWith('text')) {\n            responseType_ = 'text';\n        }\n\n        return this.httpClient.put<any>(`${this.configuration.basePath}/user/${encodeURIComponent(String(username))}`,\n            user,\n            {\n                responseType: <any>responseType_,\n                withCredentials: this.configuration.withCredentials,\n                headers: headers,\n                observe: observe,\n                reportProgress: reportProgress\n            }\n        );\n    }\n\n}\n","export * from './pet.service';\nimport { PetService } from './pet.service';\nexport * from './pet.serviceInterface'\nexport * from './store.service';\nimport { StoreService } from './store.service';\nexport * from './store.serviceInterface'\nexport * from './user.service';\nimport { UserService } from './user.service';\nexport * from './user.serviceInterface'\nexport const APIS = [PetService, StoreService, UserService];\n","/**\n * Swagger Petstore - OpenAPI 3.0\n * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we\\'ve switched to the design first approach! You can now help us improve the API whether it\\'s by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\n *\n * The version of the OpenAPI document: 1.0.9\n * Contact: apiteam@swagger.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport interface Order { \n    id?: number;\n    petId?: number;\n    quantity?: number;\n    shipDate?: string;\n    /**\n     * Order Status\n     */\n    status?: Order.StatusEnum;\n    complete?: boolean;\n}\nexport namespace Order {\n    export type StatusEnum = 'placed' | 'approved' | 'delivered';\n    export const StatusEnum = {\n        Placed: 'placed' as StatusEnum,\n        Approved: 'approved' as StatusEnum,\n        Delivered: 'delivered' as StatusEnum\n    };\n}\n\n\n","/**\n * Swagger Petstore - OpenAPI 3.0\n * This is a sample Pet Store Server based on the OpenAPI 3.0 specification.  You can find out more about Swagger at [http://swagger.io](http://swagger.io). In the third iteration of the pet store, we\\'ve switched to the design first approach! You can now help us improve the API whether it\\'s by making changes to the definition itself or to the code. That way, with time, we can improve the API in general, and expose some of the new features in OAS3.  Some useful links: - [The Pet Store repository](https://github.com/swagger-api/swagger-petstore) - [The source API definition for the Pet Store](https://github.com/swagger-api/swagger-petstore/blob/master/src/main/resources/openapi.yaml)\n *\n * The version of the OpenAPI document: 1.0.9\n * Contact: apiteam@swagger.io\n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\nimport { Category } from './category';\nimport { Tag } from './tag';\n\n\nexport interface Pet { \n    id?: number;\n    name: string;\n    category?: Category;\n    photoUrls: Array<string>;\n    tags?: Array<Tag>;\n    /**\n     * pet status in the store\n     */\n    status?: Pet.StatusEnum;\n}\nexport namespace Pet {\n    export type StatusEnum = 'available' | 'pending' | 'sold';\n    export const StatusEnum = {\n        Available: 'available' as StatusEnum,\n        Pending: 'pending' as StatusEnum,\n        Sold: 'sold' as StatusEnum\n    };\n}\n\n\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\nimport { Configuration } from './configuration';\nimport { HttpClient } from '@angular/common/http';\n\nimport { PetService } from './api/pet.service';\nimport { StoreService } from './api/store.service';\nimport { UserService } from './api/user.service';\n\n@NgModule({\n  imports:      [],\n  declarations: [],\n  exports:      [],\n  providers: []\n})\nexport class ApiModule {\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders<ApiModule> {\n        return {\n            ngModule: ApiModule,\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\n        };\n    }\n\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\n                 @Optional() http: HttpClient) {\n        if (parentModule) {\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\n        }\n        if (!http) {\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\n            'See also https://github.com/angular/angular/issues/20575');\n        }\n    }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":["InjectionToken","HttpHeaders","HttpParams","Injectable","HttpClient","Optional","Inject","Order","Pet","NgModule","SkipSelf"],"mappings":"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"}